apiVersion: apps/v1
kind: Deployment
metadata:
  name: asr-api # Name of the deployment
  namespace: asr-system # Namespace where the deployment will be created
  labels:
    app: asr-api # Label to identify this deployment
spec:
  replicas: 3 # Number of pod replicas to maintain - provides high availability
  selector:
    matchLabels:
      app: asr-api # Selector to identify which pods are managed by this deployment
  strategy:
    type: RollingUpdate # Update strategy - ensures zero downtime during updates
    rollingUpdate:
      maxSurge: 1 # Maximum number of pods that can be created over desired number during update
      maxUnavailable: 0 # No pods can be unavailable during the update - ensures availability
  template:
    metadata:
      labels:
        app: asr-api # Labels applied to the pods created by this deployment
      annotations:
        prometheus.io/scrape: 'true' # Enable Prometheus metrics scraping
        prometheus.io/port: '8000' # Port where metrics are exposed
        prometheus.io/path: /metrics # Path where metrics are available
    spec:
      affinity:
        podAntiAffinity: # Ensures pods are distributed across different nodes
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100   # High weight makes this rule strongly preferred
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - asr-api       # Avoid scheduling pods with this label on the same node
              topologyKey: kubernetes.io/hostname   # Use hostname as the topology key
      initContainers:
      - name: prepare-app-structure
        image: busybox
        command: ["/bin/sh", "-c"]
        args:
          - >
            if [ ! -d /app/src/models ]; then
              mkdir -p /app/src/models;
              echo "Creating module structure for src.models";
              echo "# Empty init file for module discovery" > /app/src/__init__.py;
              echo "# Empty init file for module discovery" > /app/src/models/__init__.py;
              echo "# Stub module for inference_model.py" > /app/src/models/inference_model.py;
              echo "class ASRInferenceModel:" >> /app/src/models/inference_model.py;
              echo "    def __init__(self):" >> /app/src/models/inference_model.py;
              echo "        pass" >> /app/src/models/inference_model.py;
              echo "" >> /app/src/models/inference_model.py;
              echo "def create_asr_model(*args, **kwargs):" >> /app/src/models/inference_model.py;
              echo "    return ASRInferenceModel()" >> /app/src/models/inference_model.py;
            fi
        volumeMounts:
        - name: app-volume
          mountPath: /app
      containers:
      - name: asr-api
        image: tuandung12092002/asr-fastapi-server:latest   # Container image to use
        imagePullPolicy: Always   # Always pull the latest image version
        # command: [/bin/bash, -c]
        ports:
        - containerPort: 8000     # Port exposed by the container
          name: http     # Name for the port
        resources:   # Resource allocation and limits
          requests:   # Minimum resources needed
            memory: 512Mi
            cpu: 500m    # Increased to match docker-compose
          limits:   # Maximum resources allowed
            memory: 1Gi
            cpu: 1000m    # Increased to match docker-compose (1 CPU)
        env:   # Environment variables for the container
        - name: PYTHONPATH     # Configure Python module search path
          value: "/app:/app/src"
        - name: PYTHONUNBUFFERED     # Added from Dockerfile
          value: '1'
        - name: PYTHONDONTWRITEBYTECODE     # Added from Dockerfile
          value: '1'
        - name: INFERENCE_DEVICE     # Set device for model inference
          value: cpu
        - name: PORT     # Set API server port
          value: '8000'
        - name: ENABLE_TRACING     # Enable distributed tracing
          value: 'true'
        - name: JAEGER_HOST     # Updated Jaeger host to match service discovery in k8s
          value: jaeger-agent.observability.svc.cluster.local
        - name: JAEGER_PORT     # Jaeger collector port
          value: '6831'
        - name: SERVICE_NAME     # Service name for tracing
          value: asr-api
        - name: SKIP_OTEL_MIDDLEWARE     # Added from Dockerfile
          value: 'true'
        - name: PROMETHEUS_MULTIPROC_DIR     # Directory for Prometheus metrics in multi-process mode
          value: /tmp/prometheus-metrics
        volumeMounts:   # Mount volumes into the container
        - name: prometheus-metrics     # Volume for storing Prometheus metrics
          mountPath: /tmp/prometheus-metrics
        - name: app-volume
          mountPath: /app
        livenessProbe:   # Checks if the container is running
          httpGet:
            path: /health   # Health check endpoint
            port: 8000
          initialDelaySeconds: 60   # Reduced from 180s to 60s to better match Dockerfile
          periodSeconds: 200   # Increased to match Dockerfile's interval
          timeoutSeconds: 30   # Timeout after 30 seconds
          failureThreshold: 3   # Reduced from 6 to 3
        readinessProbe:   # Checks if the container is ready to serve requests
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 60   # Reduced from 180s to 60s
          periodSeconds: 60   # Kept at 60s for more frequent readiness checks
          timeoutSeconds: 30   # Timeout after 30 seconds
          failureThreshold: 3   # Kept at 3
        startupProbe:   # Checks if the container has started successfully
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 40   # Reduced to match Dockerfile's start-period
          periodSeconds: 20   # More frequent checks during startup
          timeoutSeconds: 30   # Timeout after 30 seconds
          failureThreshold: 10   # 10 retries = up to ~3.5 minutes for startup
      volumes: # Volumes used by the pod
      - name: prometheus-metrics   # Volume for Prometheus metrics
        emptyDir: {}   # Ephemeral volume that exists for the pod's lifetime
      - name: app-volume
        emptyDir: {}   # Shared volume between init container and main container
